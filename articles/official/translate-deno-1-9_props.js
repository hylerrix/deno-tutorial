import projectConfig from '/pagic.config.js';
import Ga from '/_ga.js';
import Gitalk from '/_gitalk.js';
export default {
    'prev': {
        "text": "精读《Deno v1.8 发布说明》",
        "link": "articles/official/thoroughgoing-deno-1-8.html"
    },
    'next': {
        "link": "articles/translation/index.html",
        "text": "翻译篇"
    },
    config: { "root": "/", ...projectConfig, branch: 'main' },
    'pagePath': "articles/official/translate-deno-1-9.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "articles/official/translate-deno-1-9.html",
    'title': "译《Deno v1.9 发布说明》",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>译《Deno v1.9 发布说明》</h1>\n<blockquote>\n<ul>\n<li>原文地址：<a href="https://deno.com/blog/v1.9">Deno 1.9 Release Notes</a></li>\n<li>原文作者：Bartek Iwańczuk, Luca Casonato, Ryan Dahl, Aaron O\'Mullan</li>\n<li>译者：<a href="https://github.com/hylerrix">@hylerrix</a></li>\n<li>原文发布时间/翻译时间：20210413/20210430</li>\n<li>本文属于《<a href="https://github.com/hylerrix/deno-tutorial">Deno 钻研之术</a>》系列。</li>\n</ul>\n</blockquote>\n<p>今天我们发布了 Deno v1.9.0。此版本包含了许多新功能、性能优化以及 Bug 修复：</p>\n<ul>\n<li><strong>原生 HTTP/2 Web 服务器</strong>：Deno 下的一个快速、准确、功能完整的 HTTP 服务器。</li>\n<li><strong>使用 serde_v8 更快地调用 Rust</strong>：将我们的 op 基准开销优化了 98%。</li>\n<li><strong>Blob URL 支持与 <strong><code>**fetch**</code></strong> 改进</strong>：新的 Web 兼容性功能。</li>\n<li><strong>LSP 中 import 的支持更完整</strong>：本地、远程和注册表的支持现可以再次使用。</li>\n<li><strong>交互式权限提示框</strong>：以交互式提示框来请求权限而无须预先声明。</li>\n</ul>\n<p>如果你已经安装了 Deno，可以通过 <code>deno upgrade</code> 命令来更新到 1.9 版本。如果你是第一次体验 Deno，你可以尝试使用如下命令之一：</p>\n<pre class="language-bash"><code class="language-bash"><span class="token comment"># Using Shell (macOS and Linux):</span>\n<span class="token function">curl</span> -fsSL <a class="token url-link" href="https://deno.land/x/install/install.sh">https://deno.land/x/install/install.sh</a> <span class="token operator">|</span> <span class="token function">sh</span>\n\n<span class="token comment"># Using PowerShell (Windows):</span>\niwr <a class="token url-link" href="https://deno.land/x/install/install.ps1">https://deno.land/x/install/install.ps1</a> -useb <span class="token operator">|</span> iex\n\n<span class="token comment"># Using Homebrew (macOS):</span>\nbrew <span class="token function">install</span> deno\n\n<span class="token comment"># Using Scoop (Windows):</span>\nscoop <span class="token function">install</span> deno\n\n<span class="token comment"># Using Chocolatey (Windows):</span>\nchoco <span class="token function">install</span> deno\n</code></pre>\n<h2 id="%E5%8E%9F%E7%94%9F-http2-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">原生 HTTP/2 Web 服务器<a class="anchor" href="#%E5%8E%9F%E7%94%9F-http2-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">§</a></h2>\n<p>目前 Deno 下的 HTTP 服务器 <a href="https://deno.land/std/http">std/http</a>，是在 TCP 套接字顶部用纯 TypeScript 实现。尽管用了脚本化的 HTTP 服务器，但其依然具有良好的尾部延迟。但是  std/http 的主要缺点在于，它仅仅是 HTTP/1.1，没有提供通向 HTTP/2 的便捷方法。</p>\n<p>最终，我们不想忙于编写 HTTP 服务器的工作。HTTP 变得越来越重要，并且在底层代码里已经存在了良好实现的 HTTP 服务器。</p>\n<p>因此，我们使用 <a href="https://hyper.rs/">Hyper</a> 来在 Deno 中构建新的原生 HTTP/2 服务器 API。</p>\n<p>与纯 TypeScript 编写的 HTTP 服务器 std/http 相比，该绑定将 http-world 的吞吐量提高了 48%。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1618885267588-a8833216-e0b2-46d8-bb2d-8d32fa40a452.png#height=576&amp;id=hO1uu&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=576&amp;originWidth=864&amp;originalType=binary&amp;size=45678&amp;status=done&amp;style=none&amp;width=864" alt="">\n我们希望尽快稳定这个新的 API，但是现在你必须使用 <code>--unstable</code> 标志。欢迎进行测试并给我们提供反馈。</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> body <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> conn <span class="token keyword">of</span> Deno<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">{</span> port<span class="token operator">:</span> <span class="token number">4500</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">{</span> respondWith <span class="token punctuation">}</span> <span class="token keyword">of</span> Deno<span class="token punctuation">.</span><span class="token function">serveHttp</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">respondWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>我们已经很谨慎地使用与 <strong>fetch()</strong> API 相同的 <strong>Request</strong> 和 <strong>Response</strong> 对象。Rust 和 Response 对象都具有流体（streamable bodies），允许与客户端进行全双工通信。</p>\n<p>另请参考下文关于 ALPN 的部分，这是通过 TLS 发布 HTTP/2 所必需的。</p>\n<h2 id="%E4%BD%BF%E7%94%A8-serde_v8-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E8%B0%83%E7%94%A8-rust">使用 serde_v8 更快地调用 Rust<a class="anchor" href="#%E4%BD%BF%E7%94%A8-serde_v8-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E8%B0%83%E7%94%A8-rust">§</a></h2>\n<p>我们已经将绑定基础设施重建得更加简单和快捷：我们从核心中删除了 1500 多行代码，将基线绑定（又称为 ops 或 opcall）的开销提高了约 65 倍或 -98%，并且建立了干净的 op 基础，可以为我们的发展提供良好的基础（比如用于插件和未来的优化等）。</p>\n<p>在 Deno 的早期版本中，opcalls 遵循请求/响应模式，在 ArrayBuffer 的自定义“有效负载”中对其数据进行编码。此前，这些有效负载使用范围从 JSON、flatbuffers 到自定义二进制编码的各种编码...这不仅成为性能瓶颈，也成为复杂性和碎片化的重要起源。</p>\n<p><a href="https://github.com/AaronO">@AaronO</a> 建议，与其在这些二进制格式（JS 和 Rust）之间来回序列化，<a href="https://github.com/denoland/deno/issues/9540">不如直接更有效率地</a>在 v8 和 Rust 值之间进行序列化。在此建议和一个快速的原型设计下，<a href="https://github.com/denoland/deno/tree/main/serde_v8">serde_v8</a> 诞生。<code>serde_v8</code> 旨在在 v8 和 Rust 之间提供“最大效率”或“零开销”的双射，同时保持表达性和准确性（因为它建立在 David Tolnay 奇妙的 <a href="https://github.com/serde-rs/serde">serde</a> 库之上）。</p>\n<p>基线 op 开销是衡量给定类 opcall 的最小开销 （单位为每个调用的纳秒） 的一个重要基准。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619651649773-15561fc4-5a83-4e3e-9db5-c750340b2734.png#height=768&amp;id=gwrKs&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=768&amp;originWidth=1536&amp;originalType=binary&amp;size=59100&amp;status=done&amp;style=none&amp;width=1536" alt=""></p>\n<p>这些 op-layer 的改进不仅仅是学术上的，还大大提升了 Deno 的效率，也提高了我们在 <a href="https://deno.com/blog/v1.9#http-benches">HTTP 基准测试</a>的吞吐量和延迟。你可以在你自己的 Deno 程序中看到在重负荷下或者是以前遇到的 opcall 效率瓶颈时的改进。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619651701252-8ed60358-9325-48d9-8b4b-66974f2928bc.png#height=768&amp;id=RM2Va&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=768&amp;originWidth=1536&amp;originalType=binary&amp;size=61096&amp;status=done&amp;style=none&amp;width=1536" alt=""></p>\n<p>如上所见，Deno 中很多常用的功能现在都可以快 ~3 倍地运行。</p>\n<h2 id="%E6%94%AF%E6%8C%81-blob-url-%E4%B8%8E%E6%94%B9%E8%BF%9B-fetch">支持 Blob URL 与改进 <code>fetch</code><a class="anchor" href="#%E6%94%AF%E6%8C%81-blob-url-%E4%B8%8E%E6%94%B9%E8%BF%9B-fetch">§</a></h2>\n<p>此版本下，我们引入了 <code>blob:</code>（又称 object URLs）——一个与浏览器中相同的，可以用来创建和撤销 blob URL 的 API：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Hello World!"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blob:null/7b09af21-03d5-461e-90a3-af329667d0ac</span>\n\n<span class="token keyword">const</span> resp <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!</span>\n\n<span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>Blob URLs 可用于 <code>fetch</code>，使用 <code>new Worker</code> 来实例化 Web Worker，以及动态导入（使用<code>import()</code>）。</p>\n<p>除了 blob URLS，<code>fetch</code> 现在还支持 <code>data</code> URLs：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> resp <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"data:text/plain;base64,SGVsbG8gV29ybGQh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!</span>\n</code></pre>\n<h2 id="lsp-%E4%B8%AD-import-%E7%9A%84%E6%94%AF%E6%8C%81%E6%9B%B4%E5%AE%8C%E6%95%B4">LSP 中 import 的支持更完整<a class="anchor" href="#lsp-%E4%B8%AD-import-%E7%9A%84%E6%94%AF%E6%8C%81%E6%9B%B4%E5%AE%8C%E6%95%B4">§</a></h2>\n<p>此版本中，还为 Deno Language Server（一个为 Deno 提供编辑器拓展功能的工具）添加了一些很棒的新功能和改进。</p>\n<p>首先，我们从旧的 VS Code 拓展中改进并重新引入了导入补全功能。它允许用户在 import 语句中获得补全。LSP 提供本地文件的补全、已经下载到 DENO——DIR 缓存的文件以及注册表的补全。</p>\n<p>这是功能的示例：</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619674354680-5d0fc90d-59f9-4a47-be4c-58526873ad75.png#height=373&amp;id=ztKIY&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=731&amp;originalType=binary&amp;size=226251&amp;status=done&amp;style=none&amp;width=731" alt=""></p>\n<p>想要开启 <a href="https://deno.land/x">https://deno.land/x</a> 仓库的补全功能，需要在你的 VS Code（或其它编辑器） 中添加如下配置：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>\n  <span class="token string">"deno"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"suggest"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token string">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token string">"hosts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token string">"<a class="token url-link" href="https://deno.land">https://deno.land</a>"</span><span class="token operator">:</span> <span class="token boolean">true</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注册表自动补全功能目前由 <a href="https://deno.land/x">https://deno.land/x</a> 提供。我们希望更多的其它注册表会根据注册表协议来支持这个功能。<a href="https://skypack.dev/">Skypack</a> 注册表显示出了相关兴趣，并且可能很快会得到支持。如果要添加对自己注册表的支持，则可以阅读<a href="https://github.com/denoland/vscode_deno/blob/main/docs/ImportCompletions.md#module-registry-completions">注册表实现文档</a>。</p>\n<p>除了新的导入补全功能之外，我们还实现了 <code>textDocument/foldingRange</code> 和 <code>textDocument/selectionRange</code> 的 LSP 函数，使你的编辑器可以再选择期间提供更好地文本捕捉，并更好地支持折叠和拓展代码块。</p>\n<p>此版本还包含许多针对 LSP 的错误修复，其中一个特殊的缺陷是 Windows 系统上的一个讨厌的错误：当 LSP 遇到特定的 <code>file://</code> URL时，会导致 LSP 崩溃。</p>\n<h2 id="--allow-env-%E5%92%8C---allow-run-%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95"><code>--allow-env</code> 和 <code>--allow-run</code> 的白名单<a class="anchor" href="#--allow-env-%E5%92%8C---allow-run-%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95">§</a></h2>\n<p>Deno 的多个权限标志接收一个允许列表，使得程序权限可以再细粒度地得到控制。例如，使用 <code>--allow-read=/tmp</code> 仅授予对 <code>/tmp</code> 目录的读取权限。</p>\n<p>在 1.9 之前的版本中，<code>--allow-env</code> 和 <code>--allow-run</code> 都是全部开启或全部关闭，这意味着通过这些标志将授予对环境变量的完全访问权限，并且可以分别为系统中的任何二进制文件生成子进程。</p>\n<p>现在可以精确地指定程序应该访问哪些环境变量，或者允许程序产生哪些子进程：</p>\n<pre class="language-bash"><code class="language-bash">$ deno run --allow-env<span class="token operator">=</span>DEBUG,LOG <a class="token url-link" href="https://deno.com/v1.9/env_permissions.ts">https://deno.com/v1.9/env_permissions.ts</a>\n$ deno run --allow-run<span class="token operator">=</span>deno <a class="token url-link" href="https://deno.com/v1.9/run_permissions.ts">https://deno.com/v1.9/run_permissions.ts</a>\n</code></pre>\n<p>此外，<code>Deno.permissions.query()</code> 现在允许使用命令字段查询执行特定二进制文件的权限：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">await</span> Deno<span class="token punctuation">.</span>permissions<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"run"</span><span class="token punctuation">,</span> command<span class="token operator">:</span> <span class="token string">"deno"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<h2 id="%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA%E6%A1%86">交互式权限提示框<a class="anchor" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA%E6%A1%86">§</a></h2>\n<p>当前在 Deno 中，如果你运行的程序确实相应的权限标志，它将抛出错误并退出。在 1.9 中，我们添加了  --pormpt 标志，允许用户迭代地授予运行时所需的权限。</p>\n<p>当从 Internet 运行一次性脚本时，使用 --prompt 尤其有用：你无需预先知道所有必需的权限，而是可以在没有任何权限的情况下运行脚本，并根据程序的请求逐一授予或拒绝。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619678240453-25965a97-de73-4537-a48a-b9589cee6fa5.png#height=200&amp;id=iC4Ki&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=686&amp;originalType=binary&amp;size=151177&amp;status=done&amp;style=none&amp;width=686" alt=""></p>\n<p>尝试运行这个示例：<code>deno run --prompt ``[https://deno.com/v1.9/prompt_permissions.ts](https://deno.com/v1.9/prompt_permissions.ts)</code>。</p>\n<p>如果 --prompt 对你有用，请告诉我们，我们正在考虑在将来的版本中默认将其打开。</p>\n<h2 id="denolistentls-%E4%B8%AD%E7%9A%84-alpn-%E6%94%AF%E6%8C%81"><code>Deno.listenTls</code> 中的 ALPN 支持<a class="anchor" href="#denolistentls-%E4%B8%AD%E7%9A%84-alpn-%E6%94%AF%E6%8C%81">§</a></h2>\n<p>HTTP/2 协议与连接无关。因此，它可以用于 Unix 套接字、TCP 套接字或者使用 TLS 的连接。主流浏览器只允许在 TLS 握手过程中宣布支持 HTTP/2 的 TLS 连接。它通过“应用层协议协商”TLS 扩展来实现，也被称为 ALPN。这种对 TLS 握手的扩展允许 TLS 服务器和客户端就它们将使用哪种应用协议来进行 TLS 连接通信进行协商。HTTP/1.1 和 HTTP/2 是网络上两个主要的应用协议。这些协议的 ALPN 名称分别为“http/1.1”和“h2”。浏览器只会将 HTTP/ 2 请求发送到声明支持 HTTP/2 的服务器。如果没有列出 ALPN 协议，或者在 ALPN 协议中只列出了“http/1.1”，则将使用 HTTP/1.1。</p>\n<p>迄今为止，<code>std/http</code> 服务器仅支持 HTTP/1.1，因此无需支持 TLS 连接上的 ALPN。当<code>Deno.serviceHttp</code> 在这一版本中引入时，事情发生了变化。要在 Deno 中实现完全的 HTTP/2，我们现在添加了对指定 ALPN 协议的支持，当 TLS 侦听器通过 <code>Deno.ListentLs</code> 启动时，它将进行公告。</p>\n<p>下面是一个创建完全支持 HTTP/2 的 HTTPS 服务器的例子：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> listener <span class="token operator">=</span> Deno<span class="token punctuation">.</span><span class="token function">listenTls</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  port<span class="token operator">:</span> <span class="token number">443</span><span class="token punctuation">,</span>\n  certFile<span class="token operator">:</span> <span class="token string">"./cert.pem"</span><span class="token punctuation">,</span>\n  keyFile<span class="token operator">:</span> <span class="token string">"./key.pem"</span><span class="token punctuation">,</span>\n  alpnProtocols<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token string">"http/1.1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> conn <span class="token keyword">of</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">handleConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>conn<span class="token operator">:</span> Deno<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> httpConn <span class="token operator">=</span> Deno<span class="token punctuation">.</span><span class="token function">serveHttp</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">{</span> request<span class="token punctuation">,</span> respondWith <span class="token punctuation">}</span> <span class="token keyword">of</span> httpConn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">respondWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Responding to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>request<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%9A%84-api">新稳定的 API<a class="anchor" href="#%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%9A%84-api">§</a></h2>\n<p>1.9 稳定了与文件系统相关的几个 API：</p>\n<ul>\n<li><code>Deno.fstat</code></li>\n<li><code>Deno.fstatSync</code></li>\n<li><code>Deno.ftruncate</code></li>\n<li><code>Deno.ftruncateSync</code></li>\n</ul>\n<p>此外如下方法加入到了 Deno.file 类中：</p>\n<ul>\n<li><code>File.stat</code></li>\n<li><code>File.statSync</code></li>\n<li><code>File.truncate</code></li>\n<li><code>File.truncateSync</code></li>\n</ul>\n<h2 id="%E6%96%B0%E5%BC%83%E7%94%A8%E7%9A%84-api">新弃用的 API<a class="anchor" href="#%E6%96%B0%E5%BC%83%E7%94%A8%E7%9A%84-api">§</a></h2>\n<p>为了使更多使用 Deno 编写的代码直接移植到浏览器和其他非 Deno 运行时中，我们决定弃用并最终从 Deno 命名空间中删除所有不受系统 API 支持的 API。这些 API 将被移植至 Deno 标准库中，该库也可以在浏览器中使用。</p>\n<p>在此版本中，我们不推荐使用以下 API：</p>\n<ul>\n<li><code>Deno.Buffer</code></li>\n<li><code>Deno.readAll</code></li>\n<li><code>Deno.readAllSync</code></li>\n<li><code>Deno.writeAll</code></li>\n<li><code>Deno.writeAllSync</code></li>\n<li><code>Deno.iter</code></li>\n<li><code>Deno.iterSync</code></li>\n</ul>\n<p>这些 API 已移至 <code>std/io</code> 模块中。我们在 <code>deno lint</code> 中引入了一个新的 lint 规则，它可以发现开发者使用这些不稳定的 API，并发出警告。它还会建议开发者在标准库找到该 API。</p>\n<p>在 Deno 2.0 中，我们计划删除这些废弃的 API。更激进的弃用信息可能会出现在 2.0 之前的版本。请尽可能快地迁移使用到这些弃用 API 的代码。</p>\n<h2 id="%E6%96%B0%E7%9A%84-typescript-%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9-usedefineforclassfields">新的 TypeScript 默认选项 <code>useDefineForClassFields</code><a class="anchor" href="#%E6%96%B0%E7%9A%84-typescript-%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9-usedefineforclassfields">§</a></h2>\n<p>在此发布中，我们修改了默认的 Deno tsconfig，包括 <code>&quot;useDefineForClassFields&quot;: true</code> 选项。这个选项使 TypeScript 对类字段的处理符合标准 ECMA 脚本语义。此选项不能在用户代码中覆盖。我们希望大部分用户不必更改代码。</p>\n<blockquote>\n<p>© <a href="https://github.com/hylerrix/deno-tutorial">https://github.com/hylerrix/deno-tutorial</a> 2020~2021</p>\n</blockquote>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement(Ga, { id: "UA-169223577-1" }),
        React.createElement("link", { href: "/favicon.png", rel: "icon", type: "image/png" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "\u8BD1\u300ADeno v1.9 \u53D1\u5E03\u8BF4\u660E\u300B"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<blockquote>\n<ul>\n<li>原文地址：<a href="https://deno.com/blog/v1.9">Deno 1.9 Release Notes</a></li>\n<li>原文作者：Bartek Iwańczuk, Luca Casonato, Ryan Dahl, Aaron O\'Mullan</li>\n<li>译者：<a href="https://github.com/hylerrix">@hylerrix</a></li>\n<li>原文发布时间/翻译时间：20210413/20210430</li>\n<li>本文属于《<a href="https://github.com/hylerrix/deno-tutorial">Deno 钻研之术</a>》系列。</li>\n</ul>\n</blockquote>\n<p>今天我们发布了 Deno v1.9.0。此版本包含了许多新功能、性能优化以及 Bug 修复：</p>\n<ul>\n<li><strong>原生 HTTP/2 Web 服务器</strong>：Deno 下的一个快速、准确、功能完整的 HTTP 服务器。</li>\n<li><strong>使用 serde_v8 更快地调用 Rust</strong>：将我们的 op 基准开销优化了 98%。</li>\n<li><strong>Blob URL 支持与 <strong><code>**fetch**</code></strong> 改进</strong>：新的 Web 兼容性功能。</li>\n<li><strong>LSP 中 import 的支持更完整</strong>：本地、远程和注册表的支持现可以再次使用。</li>\n<li><strong>交互式权限提示框</strong>：以交互式提示框来请求权限而无须预先声明。</li>\n</ul>\n<p>如果你已经安装了 Deno，可以通过 <code>deno upgrade</code> 命令来更新到 1.9 版本。如果你是第一次体验 Deno，你可以尝试使用如下命令之一：</p>\n<pre class="language-bash"><code class="language-bash"><span class="token comment"># Using Shell (macOS and Linux):</span>\n<span class="token function">curl</span> -fsSL <a class="token url-link" href="https://deno.land/x/install/install.sh">https://deno.land/x/install/install.sh</a> <span class="token operator">|</span> <span class="token function">sh</span>\n\n<span class="token comment"># Using PowerShell (Windows):</span>\niwr <a class="token url-link" href="https://deno.land/x/install/install.ps1">https://deno.land/x/install/install.ps1</a> -useb <span class="token operator">|</span> iex\n\n<span class="token comment"># Using Homebrew (macOS):</span>\nbrew <span class="token function">install</span> deno\n\n<span class="token comment"># Using Scoop (Windows):</span>\nscoop <span class="token function">install</span> deno\n\n<span class="token comment"># Using Chocolatey (Windows):</span>\nchoco <span class="token function">install</span> deno\n</code></pre>\n<h2 id="%E5%8E%9F%E7%94%9F-http2-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">原生 HTTP/2 Web 服务器<a class="anchor" href="#%E5%8E%9F%E7%94%9F-http2-web-%E6%9C%8D%E5%8A%A1%E5%99%A8">§</a></h2>\n<p>目前 Deno 下的 HTTP 服务器 <a href="https://deno.land/std/http">std/http</a>，是在 TCP 套接字顶部用纯 TypeScript 实现。尽管用了脚本化的 HTTP 服务器，但其依然具有良好的尾部延迟。但是  std/http 的主要缺点在于，它仅仅是 HTTP/1.1，没有提供通向 HTTP/2 的便捷方法。</p>\n<p>最终，我们不想忙于编写 HTTP 服务器的工作。HTTP 变得越来越重要，并且在底层代码里已经存在了良好实现的 HTTP 服务器。</p>\n<p>因此，我们使用 <a href="https://hyper.rs/">Hyper</a> 来在 Deno 中构建新的原生 HTTP/2 服务器 API。</p>\n<p>与纯 TypeScript 编写的 HTTP 服务器 std/http 相比，该绑定将 http-world 的吞吐量提高了 48%。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1618885267588-a8833216-e0b2-46d8-bb2d-8d32fa40a452.png#height=576&amp;id=hO1uu&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=576&amp;originWidth=864&amp;originalType=binary&amp;size=45678&amp;status=done&amp;style=none&amp;width=864" alt="">\n我们希望尽快稳定这个新的 API，但是现在你必须使用 <code>--unstable</code> 标志。欢迎进行测试并给我们提供反馈。</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> body <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TextEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> conn <span class="token keyword">of</span> Deno<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">{</span> port<span class="token operator">:</span> <span class="token number">4500</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">{</span> respondWith <span class="token punctuation">}</span> <span class="token keyword">of</span> Deno<span class="token punctuation">.</span><span class="token function">serveHttp</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">respondWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>我们已经很谨慎地使用与 <strong>fetch()</strong> API 相同的 <strong>Request</strong> 和 <strong>Response</strong> 对象。Rust 和 Response 对象都具有流体（streamable bodies），允许与客户端进行全双工通信。</p>\n<p>另请参考下文关于 ALPN 的部分，这是通过 TLS 发布 HTTP/2 所必需的。</p>\n<h2 id="%E4%BD%BF%E7%94%A8-serde_v8-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E8%B0%83%E7%94%A8-rust">使用 serde_v8 更快地调用 Rust<a class="anchor" href="#%E4%BD%BF%E7%94%A8-serde_v8-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E8%B0%83%E7%94%A8-rust">§</a></h2>\n<p>我们已经将绑定基础设施重建得更加简单和快捷：我们从核心中删除了 1500 多行代码，将基线绑定（又称为 ops 或 opcall）的开销提高了约 65 倍或 -98%，并且建立了干净的 op 基础，可以为我们的发展提供良好的基础（比如用于插件和未来的优化等）。</p>\n<p>在 Deno 的早期版本中，opcalls 遵循请求/响应模式，在 ArrayBuffer 的自定义“有效负载”中对其数据进行编码。此前，这些有效负载使用范围从 JSON、flatbuffers 到自定义二进制编码的各种编码...这不仅成为性能瓶颈，也成为复杂性和碎片化的重要起源。</p>\n<p><a href="https://github.com/AaronO">@AaronO</a> 建议，与其在这些二进制格式（JS 和 Rust）之间来回序列化，<a href="https://github.com/denoland/deno/issues/9540">不如直接更有效率地</a>在 v8 和 Rust 值之间进行序列化。在此建议和一个快速的原型设计下，<a href="https://github.com/denoland/deno/tree/main/serde_v8">serde_v8</a> 诞生。<code>serde_v8</code> 旨在在 v8 和 Rust 之间提供“最大效率”或“零开销”的双射，同时保持表达性和准确性（因为它建立在 David Tolnay 奇妙的 <a href="https://github.com/serde-rs/serde">serde</a> 库之上）。</p>\n<p>基线 op 开销是衡量给定类 opcall 的最小开销 （单位为每个调用的纳秒） 的一个重要基准。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619651649773-15561fc4-5a83-4e3e-9db5-c750340b2734.png#height=768&amp;id=gwrKs&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=768&amp;originWidth=1536&amp;originalType=binary&amp;size=59100&amp;status=done&amp;style=none&amp;width=1536" alt=""></p>\n<p>这些 op-layer 的改进不仅仅是学术上的，还大大提升了 Deno 的效率，也提高了我们在 <a href="https://deno.com/blog/v1.9#http-benches">HTTP 基准测试</a>的吞吐量和延迟。你可以在你自己的 Deno 程序中看到在重负荷下或者是以前遇到的 opcall 效率瓶颈时的改进。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619651701252-8ed60358-9325-48d9-8b4b-66974f2928bc.png#height=768&amp;id=RM2Va&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=768&amp;originWidth=1536&amp;originalType=binary&amp;size=61096&amp;status=done&amp;style=none&amp;width=1536" alt=""></p>\n<p>如上所见，Deno 中很多常用的功能现在都可以快 ~3 倍地运行。</p>\n<h2 id="%E6%94%AF%E6%8C%81-blob-url-%E4%B8%8E%E6%94%B9%E8%BF%9B-fetch">支持 Blob URL 与改进 <code>fetch</code><a class="anchor" href="#%E6%94%AF%E6%8C%81-blob-url-%E4%B8%8E%E6%94%B9%E8%BF%9B-fetch">§</a></h2>\n<p>此版本下，我们引入了 <code>blob:</code>（又称 object URLs）——一个与浏览器中相同的，可以用来创建和撤销 blob URL 的 API：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Hello World!"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// blob:null/7b09af21-03d5-461e-90a3-af329667d0ac</span>\n\n<span class="token keyword">const</span> resp <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!</span>\n\n<span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>Blob URLs 可用于 <code>fetch</code>，使用 <code>new Worker</code> 来实例化 Web Worker，以及动态导入（使用<code>import()</code>）。</p>\n<p>除了 blob URLS，<code>fetch</code> 现在还支持 <code>data</code> URLs：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> resp <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"data:text/plain;base64,SGVsbG8gV29ybGQh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello World!</span>\n</code></pre>\n<h2 id="lsp-%E4%B8%AD-import-%E7%9A%84%E6%94%AF%E6%8C%81%E6%9B%B4%E5%AE%8C%E6%95%B4">LSP 中 import 的支持更完整<a class="anchor" href="#lsp-%E4%B8%AD-import-%E7%9A%84%E6%94%AF%E6%8C%81%E6%9B%B4%E5%AE%8C%E6%95%B4">§</a></h2>\n<p>此版本中，还为 Deno Language Server（一个为 Deno 提供编辑器拓展功能的工具）添加了一些很棒的新功能和改进。</p>\n<p>首先，我们从旧的 VS Code 拓展中改进并重新引入了导入补全功能。它允许用户在 import 语句中获得补全。LSP 提供本地文件的补全、已经下载到 DENO——DIR 缓存的文件以及注册表的补全。</p>\n<p>这是功能的示例：</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619674354680-5d0fc90d-59f9-4a47-be4c-58526873ad75.png#height=373&amp;id=ztKIY&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=731&amp;originalType=binary&amp;size=226251&amp;status=done&amp;style=none&amp;width=731" alt=""></p>\n<p>想要开启 <a href="https://deno.land/x">https://deno.land/x</a> 仓库的补全功能，需要在你的 VS Code（或其它编辑器） 中添加如下配置：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token punctuation">{</span>\n  <span class="token string">"deno"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token string">"suggest"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token string">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token string">"hosts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token string">"<a class="token url-link" href="https://deno.land">https://deno.land</a>"</span><span class="token operator">:</span> <span class="token boolean">true</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注册表自动补全功能目前由 <a href="https://deno.land/x">https://deno.land/x</a> 提供。我们希望更多的其它注册表会根据注册表协议来支持这个功能。<a href="https://skypack.dev/">Skypack</a> 注册表显示出了相关兴趣，并且可能很快会得到支持。如果要添加对自己注册表的支持，则可以阅读<a href="https://github.com/denoland/vscode_deno/blob/main/docs/ImportCompletions.md#module-registry-completions">注册表实现文档</a>。</p>\n<p>除了新的导入补全功能之外，我们还实现了 <code>textDocument/foldingRange</code> 和 <code>textDocument/selectionRange</code> 的 LSP 函数，使你的编辑器可以再选择期间提供更好地文本捕捉，并更好地支持折叠和拓展代码块。</p>\n<p>此版本还包含许多针对 LSP 的错误修复，其中一个特殊的缺陷是 Windows 系统上的一个讨厌的错误：当 LSP 遇到特定的 <code>file://</code> URL时，会导致 LSP 崩溃。</p>\n<h2 id="--allow-env-%E5%92%8C---allow-run-%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95"><code>--allow-env</code> 和 <code>--allow-run</code> 的白名单<a class="anchor" href="#--allow-env-%E5%92%8C---allow-run-%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95">§</a></h2>\n<p>Deno 的多个权限标志接收一个允许列表，使得程序权限可以再细粒度地得到控制。例如，使用 <code>--allow-read=/tmp</code> 仅授予对 <code>/tmp</code> 目录的读取权限。</p>\n<p>在 1.9 之前的版本中，<code>--allow-env</code> 和 <code>--allow-run</code> 都是全部开启或全部关闭，这意味着通过这些标志将授予对环境变量的完全访问权限，并且可以分别为系统中的任何二进制文件生成子进程。</p>\n<p>现在可以精确地指定程序应该访问哪些环境变量，或者允许程序产生哪些子进程：</p>\n<pre class="language-bash"><code class="language-bash">$ deno run --allow-env<span class="token operator">=</span>DEBUG,LOG <a class="token url-link" href="https://deno.com/v1.9/env_permissions.ts">https://deno.com/v1.9/env_permissions.ts</a>\n$ deno run --allow-run<span class="token operator">=</span>deno <a class="token url-link" href="https://deno.com/v1.9/run_permissions.ts">https://deno.com/v1.9/run_permissions.ts</a>\n</code></pre>\n<p>此外，<code>Deno.permissions.query()</code> 现在允许使用命令字段查询执行特定二进制文件的权限：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">await</span> Deno<span class="token punctuation">.</span>permissions<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"run"</span><span class="token punctuation">,</span> command<span class="token operator">:</span> <span class="token string">"deno"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<h2 id="%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA%E6%A1%86">交互式权限提示框<a class="anchor" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA%E6%A1%86">§</a></h2>\n<p>当前在 Deno 中，如果你运行的程序确实相应的权限标志，它将抛出错误并退出。在 1.9 中，我们添加了  --pormpt 标志，允许用户迭代地授予运行时所需的权限。</p>\n<p>当从 Internet 运行一次性脚本时，使用 --prompt 尤其有用：你无需预先知道所有必需的权限，而是可以在没有任何权限的情况下运行脚本，并根据程序的请求逐一授予或拒绝。</p>\n<p><img src="https://cdn.nlark.com/yuque/0/2021/png/86548/1619678240453-25965a97-de73-4537-a48a-b9589cee6fa5.png#height=200&amp;id=iC4Ki&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=686&amp;originalType=binary&amp;size=151177&amp;status=done&amp;style=none&amp;width=686" alt=""></p>\n<p>尝试运行这个示例：<code>deno run --prompt ``[https://deno.com/v1.9/prompt_permissions.ts](https://deno.com/v1.9/prompt_permissions.ts)</code>。</p>\n<p>如果 --prompt 对你有用，请告诉我们，我们正在考虑在将来的版本中默认将其打开。</p>\n<h2 id="denolistentls-%E4%B8%AD%E7%9A%84-alpn-%E6%94%AF%E6%8C%81"><code>Deno.listenTls</code> 中的 ALPN 支持<a class="anchor" href="#denolistentls-%E4%B8%AD%E7%9A%84-alpn-%E6%94%AF%E6%8C%81">§</a></h2>\n<p>HTTP/2 协议与连接无关。因此，它可以用于 Unix 套接字、TCP 套接字或者使用 TLS 的连接。主流浏览器只允许在 TLS 握手过程中宣布支持 HTTP/2 的 TLS 连接。它通过“应用层协议协商”TLS 扩展来实现，也被称为 ALPN。这种对 TLS 握手的扩展允许 TLS 服务器和客户端就它们将使用哪种应用协议来进行 TLS 连接通信进行协商。HTTP/1.1 和 HTTP/2 是网络上两个主要的应用协议。这些协议的 ALPN 名称分别为“http/1.1”和“h2”。浏览器只会将 HTTP/ 2 请求发送到声明支持 HTTP/2 的服务器。如果没有列出 ALPN 协议，或者在 ALPN 协议中只列出了“http/1.1”，则将使用 HTTP/1.1。</p>\n<p>迄今为止，<code>std/http</code> 服务器仅支持 HTTP/1.1，因此无需支持 TLS 连接上的 ALPN。当<code>Deno.serviceHttp</code> 在这一版本中引入时，事情发生了变化。要在 Deno 中实现完全的 HTTP/2，我们现在添加了对指定 ALPN 协议的支持，当 TLS 侦听器通过 <code>Deno.ListentLs</code> 启动时，它将进行公告。</p>\n<p>下面是一个创建完全支持 HTTP/2 的 HTTPS 服务器的例子：</p>\n<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> listener <span class="token operator">=</span> Deno<span class="token punctuation">.</span><span class="token function">listenTls</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  port<span class="token operator">:</span> <span class="token number">443</span><span class="token punctuation">,</span>\n  certFile<span class="token operator">:</span> <span class="token string">"./cert.pem"</span><span class="token punctuation">,</span>\n  keyFile<span class="token operator">:</span> <span class="token string">"./key.pem"</span><span class="token punctuation">,</span>\n  alpnProtocols<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token string">"http/1.1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> conn <span class="token keyword">of</span> listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">handleConn</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handleConn</span><span class="token punctuation">(</span>conn<span class="token operator">:</span> Deno<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> httpConn <span class="token operator">=</span> Deno<span class="token punctuation">.</span><span class="token function">serveHttp</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">{</span> request<span class="token punctuation">,</span> respondWith <span class="token punctuation">}</span> <span class="token keyword">of</span> httpConn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">respondWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Responding to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>request<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%9A%84-api">新稳定的 API<a class="anchor" href="#%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%9A%84-api">§</a></h2>\n<p>1.9 稳定了与文件系统相关的几个 API：</p>\n<ul>\n<li><code>Deno.fstat</code></li>\n<li><code>Deno.fstatSync</code></li>\n<li><code>Deno.ftruncate</code></li>\n<li><code>Deno.ftruncateSync</code></li>\n</ul>\n<p>此外如下方法加入到了 Deno.file 类中：</p>\n<ul>\n<li><code>File.stat</code></li>\n<li><code>File.statSync</code></li>\n<li><code>File.truncate</code></li>\n<li><code>File.truncateSync</code></li>\n</ul>\n<h2 id="%E6%96%B0%E5%BC%83%E7%94%A8%E7%9A%84-api">新弃用的 API<a class="anchor" href="#%E6%96%B0%E5%BC%83%E7%94%A8%E7%9A%84-api">§</a></h2>\n<p>为了使更多使用 Deno 编写的代码直接移植到浏览器和其他非 Deno 运行时中，我们决定弃用并最终从 Deno 命名空间中删除所有不受系统 API 支持的 API。这些 API 将被移植至 Deno 标准库中，该库也可以在浏览器中使用。</p>\n<p>在此版本中，我们不推荐使用以下 API：</p>\n<ul>\n<li><code>Deno.Buffer</code></li>\n<li><code>Deno.readAll</code></li>\n<li><code>Deno.readAllSync</code></li>\n<li><code>Deno.writeAll</code></li>\n<li><code>Deno.writeAllSync</code></li>\n<li><code>Deno.iter</code></li>\n<li><code>Deno.iterSync</code></li>\n</ul>\n<p>这些 API 已移至 <code>std/io</code> 模块中。我们在 <code>deno lint</code> 中引入了一个新的 lint 规则，它可以发现开发者使用这些不稳定的 API，并发出警告。它还会建议开发者在标准库找到该 API。</p>\n<p>在 Deno 2.0 中，我们计划删除这些废弃的 API。更激进的弃用信息可能会出现在 2.0 之前的版本。请尽可能快地迁移使用到这些弃用 API 的代码。</p>\n<h2 id="%E6%96%B0%E7%9A%84-typescript-%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9-usedefineforclassfields">新的 TypeScript 默认选项 <code>useDefineForClassFields</code><a class="anchor" href="#%E6%96%B0%E7%9A%84-typescript-%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9-usedefineforclassfields">§</a></h2>\n<p>在此发布中，我们修改了默认的 Deno tsconfig，包括 <code>&quot;useDefineForClassFields&quot;: true</code> 选项。这个选项使 TypeScript 对类字段的处理符合标准 ECMA 脚本语义。此选项不能在用户代码中覆盖。我们希望大部分用户不必更改代码。</p>\n<blockquote>\n<p>© <a href="https://github.com/hylerrix/deno-tutorial">https://github.com/hylerrix/deno-tutorial</a> 2020~2021</p>\n</blockquote>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#%E5%8E%9F%E7%94%9F-http2-web-%E6%9C%8D%E5%8A%A1%E5%99%A8" }, "\u539F\u751F HTTP/2 Web \u670D\u52A1\u5668")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E4%BD%BF%E7%94%A8-serde_v8-%E6%9B%B4%E5%BF%AB%E5%9C%B0%E8%B0%83%E7%94%A8-rust" }, "\u4F7F\u7528 serde_v8 \u66F4\u5FEB\u5730\u8C03\u7528 Rust")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E6%94%AF%E6%8C%81-blob-url-%E4%B8%8E%E6%94%B9%E8%BF%9B-fetch" }, "\u652F\u6301 Blob URL \u4E0E\u6539\u8FDB fetch")),
            React.createElement("li", null,
                React.createElement("a", { href: "#lsp-%E4%B8%AD-import-%E7%9A%84%E6%94%AF%E6%8C%81%E6%9B%B4%E5%AE%8C%E6%95%B4" }, "LSP \u4E2D import \u7684\u652F\u6301\u66F4\u5B8C\u6574")),
            React.createElement("li", null,
                React.createElement("a", { href: "#--allow-env-%E5%92%8C---allow-run-%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95" }, "--allow-env \u548C --allow-run \u7684\u767D\u540D\u5355")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9D%83%E9%99%90%E6%8F%90%E7%A4%BA%E6%A1%86" }, "\u4EA4\u4E92\u5F0F\u6743\u9650\u63D0\u793A\u6846")),
            React.createElement("li", null,
                React.createElement("a", { href: "#denolistentls-%E4%B8%AD%E7%9A%84-alpn-%E6%94%AF%E6%8C%81" }, "Deno.listenTls \u4E2D\u7684 ALPN \u652F\u6301")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%9A%84-api" }, "\u65B0\u7A33\u5B9A\u7684 API")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E6%96%B0%E5%BC%83%E7%94%A8%E7%9A%84-api" }, "\u65B0\u5F03\u7528\u7684 API")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E6%96%B0%E7%9A%84-typescript-%E9%BB%98%E8%AE%A4%E9%80%89%E9%A1%B9-usedefineforclassfields" }, "\u65B0\u7684 TypeScript \u9ED8\u8BA4\u9009\u9879 useDefineForClassFields")))),
    'author': "hylerrix",
    'contributors': [
        "hylerrix"
    ],
    'date': "2021-03-23T03:11:47.000Z",
    'updated': null,
    'excerpt': "今天我们发布了 Deno v1.9.0。此版本包含了许多新功能、性能优化以及 Bug 修复： - 原生 HTTP/2 Web 服务器：Deno 下的一个快速、准确、功能完整的 HTTP 服务器。 - 使用 serde_v8 更快地调用 Rust：将我们的 op 基准开销优化了...",
    'cover': "https://cdn.nlark.com/yuque/0/2021/png/86548/1618885267588-a8833216-e0b2-46d8-bb2d-8d32fa40a452.png#height=576&id=hO1uu&margin=%5Bobject%20Object%5D&name=image.png&originHeight=576&originWidth=864&originalType=binary&size=45678&status=done&style=none&width=864",
    'sidebar': [
        {
            "text": "Deno 钻研之术",
            "link": "articles/index.html",
            "pagePath": "articles/README.md"
        },
        {
            "link": "articles/document/index.html",
            "title": "文档篇",
            "children": [
                {
                    "text": "Deno 版本历史概览",
                    "link": "articles/document/deno-version-handbook.html",
                    "pagePath": "articles/document/deno-version-handbook.md"
                },
                {
                    "text": "Deno CLI 通用手册",
                    "link": "articles/document/deno-cli-handbook.html",
                    "pagePath": "articles/document/deno-cli-handbook.md"
                },
                {
                    "text": "Deno 专业术语翻译手册",
                    "link": "articles/document/deno-translation-dictionary.html",
                    "pagePath": "articles/document/deno-translation-dictionary.md"
                }
            ],
            "pagePath": "articles/document/README.md",
            "text": "文档篇"
        },
        {
            "link": "articles/basic/index.html",
            "title": "基础篇",
            "children": [
                {
                    "text": "Hello，从多样化安装到简单实战",
                    "link": "articles/basic/install-and-hello-world.html",
                    "pagePath": "articles/basic/install-and-hello-world.md"
                }
            ],
            "pagePath": "articles/basic/README.md",
            "text": "基础篇"
        },
        {
            "link": "articles/architecture/index.html",
            "title": "架构篇",
            "children": [
                {
                    "link": "articles/architecture/cli/index.html",
                    "title": "探索 CLI",
                    "children": [
                        {
                            "text": "从 CLI 指令通读 Deno v1.x 全特性",
                            "link": "articles/architecture/cli/deno-cli-v1-function.html",
                            "pagePath": "articles/architecture/cli/deno-cli-v1-function.md"
                        }
                    ],
                    "pagePath": "articles/architecture/cli/README.md",
                    "text": "CLI 篇"
                }
            ],
            "pagePath": "articles/architecture/README.md",
            "text": "架构篇"
        },
        {
            "link": "articles/ecology/index.html",
            "title": "生态篇",
            "children": [
                {
                    "text": "Awesome Deno 中文资源全图谱",
                    "link": "articles/ecology/awesome-deno-cn.html",
                    "pagePath": "articles/ecology/awesome-deno-cn.md"
                }
            ],
            "pagePath": "articles/ecology/README.md",
            "text": "生态篇"
        },
        {
            "link": "articles/official/index.html",
            "title": "官方篇",
            "children": [
                {
                    "text": "精读《Deno 2020 官方回顾及 2021 展望》",
                    "link": "articles/official/thoroughgoing-deno-in-2020.html",
                    "pagePath": "articles/official/thoroughgoing-deno-in-2020.md"
                },
                {
                    "text": "精读《Deno v1.8 发布说明》",
                    "link": "articles/official/thoroughgoing-deno-1-8.html",
                    "pagePath": "articles/official/thoroughgoing-deno-1-8.md"
                },
                {
                    "text": "译《Deno v1.9 发布说明》",
                    "link": "articles/official/translate-deno-1-9.html",
                    "pagePath": "articles/official/translate-deno-1-9.md"
                }
            ],
            "pagePath": "articles/official/README.md",
            "text": "官方篇"
        },
        {
            "link": "articles/translation/index.html",
            "title": "翻译篇",
            "children": [
                {
                    "text": "Deno 入门手册：附大量 TypeScript 代码实例",
                    "link": "articles/translation/the-deno-handbook.html",
                    "pagePath": "articles/translation/the-deno-handbook.md"
                },
                {
                    "text": "Deno + WebSockets 打造聊天室应用",
                    "link": "articles/translation/deno-chat-app.html",
                    "pagePath": "articles/translation/deno-chat-app.md"
                },
                {
                    "text": "从 Node 到 Deno：探索各大主流库替代方案",
                    "link": "articles/translation/from-node-to-deno.html",
                    "pagePath": "articles/translation/from-node-to-deno.md"
                },
                {
                    "text": "Deno + Oak 构建酷炫的 Todo API",
                    "link": "articles/translation/deno-oak-todo-api.html",
                    "pagePath": "articles/translation/deno-oak-todo-api.md"
                },
                {
                    "text": "Deno + Oak 连接 MySQL 实战教程",
                    "link": "articles/translation/deno-oak-mysql.html",
                    "pagePath": "articles/translation/deno-oak-mysql.md"
                },
                {
                    "text": "为什么我认为 Deno 是一个迈向错误方向的 JavaScript 运行时？",
                    "link": "articles/translation/why-deno-wrong.html",
                    "pagePath": "articles/translation/why-deno-wrong.md"
                },
                {
                    "text": "为什么 Deno 没有众望所归？超越 Node.js 还要做些什么？",
                    "link": "articles/translation/why-deno-flopped.html",
                    "pagePath": "articles/translation/why-deno-flopped.md"
                },
                {
                    "text": "如何在 Deno 中构建一个 URL 短链生成器",
                    "link": "articles/translation/deno-url-shortener.html",
                    "pagePath": "articles/translation/deno-url-shortener.md"
                },
                {
                    "text": "如何在 Deno 下使用 AlpehJS 库构建 React 应用",
                    "link": "articles/translation/deno-alpeh-react.html",
                    "pagePath": "articles/translation/deno-alpeh-react.md"
                }
            ],
            "pagePath": "articles/translation/README.md",
            "text": "翻译篇"
        },
        {
            "link": "articles/rust/index.html",
            "title": "Rust 篇",
            "children": [
                {
                    "text": "Rust 语言入门教程：从实战 To-Do App 开始",
                    "link": "articles/rust/rust-tutorial-todo-app.html",
                    "pagePath": "articles/rust/rust-tutorial-todo-app.md"
                }
            ],
            "pagePath": "articles/rust/README.md",
            "text": "Rust 篇"
        },
        {
            "text": "开发日志",
            "link": "articles/TIMELINE.html",
            "pagePath": "articles/TIMELINE.md"
        },
        {
            "text": "感谢",
            "link": "articles/THANKS.html",
            "pagePath": "articles/THANKS.md"
        }
    ],
    'gitalk': React.createElement(Gitalk, { admin: [
            'hylerrix'
        ], clientID: "60180eea2c09238f8998", clientSecret: "e9ea0ff6555185eda28eff4dfd4b755b1764abf3", id: "articles/official/translate-deno-1-9.html", owner: "hylerrix", pagerDirection: "first", repo: "deno-tutorial", title: "\u8BD1\u300ADeno v1.9 \u53D1\u5E03\u8BF4\u660E\u300B" })
};
